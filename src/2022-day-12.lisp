(defpackage 2022-day-12
  (:use :cl :iterate :cl-ppcre :metabang-bind :trivia :trivia.ppcre)
  (:shadowing-import-from :arrow-macros :->>))
(in-package 2022-day-12)

(defun part-1 ()
  (bind (((map
           (start-x . start-y)
           (end-x . end-y))
          (with-open-file (f (asdf:system-relative-pathname :advent-of-code-2022-in-common-lisp "src/2022-day-12.in"))
               (do ((line (read-line f nil nil) (read-line f nil nil))
                    (lines (list))
                    (start nil)
                    (end nil))
                   ((null line) (let ((output (make-array (list (length lines)
                                                                (length (car lines)))))
                                      (y 0))
                                  (dolist (line (nreverse lines)
                                                (list output start end))
                                    (dotimes (x (length line))
                                      (cond
                                        ((eq #\S (aref line x))
                                         (setf start (cons x y)))
                                        ((eq #\E (aref line x))
                                         (progn
                                           (setf (aref output y x)
                                                 (1+ (- (char-code #\z)
                                                        (char-code #\a))))
                                           (setf end (cons x y))))
                                        (t
                                         (setf (aref output y x)
                                               (- (char-code (aref line x))
                                                  (char-code #\a))))))
                                    (incf y))))
                 (push line lines))))
         (q (datastructures::create-heap :key #'car
                                         :less #'<))
         (dist (make-array (array-dimensions map) :initial-element most-positive-fixnum))
         (parent (make-array (array-dimensions map) :initial-element nil)))
    (datastructures::insert q (list 0 start-x start-y))
    (setf (aref dist start-y start-x) 0)
    (iter
      (for (d x y) = (datastructures::del-min q))
      (for distance = (aref dist y x))
      (when (= d distance)
        (iter
          (for xx
               from (max 0 (1- x))
               to (min (1+ x) (1- (array-dimension map 1))))
          (iter
            (for yy
                 from (max 0 (1- y))
                 to (min (1+ y) (1- (array-dimension map 0))))
            (when (> (+ (abs (- x xx))
                        (abs (- y yy)))
                     1)
              (next-iteration))
            (let ((new-distance (1+ d))
                  (old-distance (aref dist yy xx)))
              (when (and (not (and (= x xx)
                                   (= y yy)))
                         (< new-distance old-distance)
                         (<= (- (aref map yy xx)
                                (aref map y x))
                             1))
                (setf (aref parent yy xx) (cons x y))
                (setf (aref dist yy xx) new-distance)
                (datastructures::insert q (list new-distance xx yy)))))))
      (while (not (datastructures::heap-empty q))))
    (aref dist end-y end-x)))

;; Correct: 484

(defun part-2 ()
  (bind (((map (end-x . end-y))
          (with-open-file (f (asdf:system-relative-pathname :advent-of-code-2022-in-common-lisp "src/2022-day-12.in"))
               (do ((line (read-line f nil nil) (read-line f nil nil))
                    (lines (list))
                    (end nil))
                   ((null line) (let ((output (make-array (list (length lines)
                                                                (length (car lines)))))
                                      (y 0))
                                  (dolist (line (nreverse lines)
                                                (list output end))
                                    (dotimes (x (length line))
                                      (cond
                                        ((eq #\E (aref line x))
                                         (progn
                                           (setf (aref output y x)
                                                 (1+ (- (char-code #\z)
                                                        (char-code #\a))))
                                           (setf end (cons x y))))
                                        (t
                                         (setf (aref output y x)
                                               (- (char-code (aref line x))
                                                  (char-code #\a))))))
                                    (incf y))))
                 (push line lines)))))
    (labels ((search-from (start-x start-y)
               (let ((q (datastructures::create-heap :key #'car
                                                     :less #'<))
                     (dist (make-array (array-dimensions map) :initial-element most-positive-fixnum))
                     (parent (make-array (array-dimensions map) :initial-element nil)))
                 (datastructures::insert q (list 0 start-x start-y))
                 (setf (aref dist start-y start-x) 0)
                 (iter
                   (for (d x y) = (datastructures::del-min q))
                   (for distance = (aref dist y x))
                   (when (= d distance)
                     (iter
                       (for xx
                            from (max 0 (1- x))
                            to (min (1+ x) (1- (array-dimension map 1))))
                       (iter
                         (for yy
                              from (max 0 (1- y))
                              to (min (1+ y) (1- (array-dimension map 0))))
                         (when (> (+ (abs (- x xx))
                                     (abs (- y yy)))
                                  1)
                           (next-iteration))
                         (let ((new-distance (1+ d))
                               (old-distance (aref dist yy xx)))
                           (when (and (not (and (= x xx)
                                                (= y yy)))
                                      (< new-distance old-distance)
                                      (<= (- (aref map yy xx)
                                             (aref map y x))
                                          1))
                             (setf (aref parent yy xx) (cons x y))
                             (setf (aref dist yy xx) new-distance)
                             (datastructures::insert q (list new-distance xx yy)))))))
                   (while (not (datastructures::heap-empty q))))
                 (aref dist end-y end-x))))
      (let ((minimum most-positive-fixnum))
        (dotimes (x (array-dimension map 1) minimum)
          (dotimes (y (array-dimension map 0))
            (when (= 0 (aref map y x))
              (setf minimum (min minimum (search-from x y))))))))))

;; Correct: 478
